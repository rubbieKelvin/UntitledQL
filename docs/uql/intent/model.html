<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uql.intent.model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uql.intent.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from uql.model import ModelConfig
from uql.model import PartialUpdateTyping
from uql.model import ModelPermissionTyping
from uql.model import SelectPermissionTyping
from uql.model import UpdatePermissionTyping
from uql.model import DeletePermissionTyping
from uql.model import InsertPermissionTyping
from uql.config import UQLConfig
from uql.constants import CellFlags
from uql.constants import ModelOperations
from uql.constants import errors as errorConstants
from uql.constants import types
from uql.utils import templates as t
from uql.utils.query import makeQuery
from uql.exceptions import RequestHandlingError

from rest_framework.request import Request

from django.db import transaction
from django.db.models import Field, Model
from django.db.utils import IntegrityError

from . import IntentFunction
import typing

ModelOperationPermission: typing.TypeAlias = (
    SelectPermissionTyping
    | UpdatePermissionTyping
    | InsertPermissionTyping
    | DeletePermissionTyping
)

ModelOperationKeys: typing.TypeAlias = (
    typing.Literal[&#34;select&#34;]
    | typing.Literal[&#34;insert&#34;]
    | typing.Literal[&#34;update&#34;]
    | typing.Literal[&#34;delete&#34;]
)


class ModelIntent:
    def __init__(self, rootConfig: type[UQLConfig], modelConfig: ModelConfig) -&gt; None:
        self.modelConfig = modelConfig
        self.rootConfig = rootConfig

    @staticmethod
    def getUserIdFromRequest(request: Request) -&gt; types.Pk | None:
        return getattr(request.user, &#34;id&#34;, None)

    @staticmethod
    def getPermission(
        role: str,
        operation: ModelOperationKeys,
        permissions: dict[
            str, typing.Callable[[types.Pk | None], ModelPermissionTyping]
        ],
        userId: str | int | None = None,
    ) -&gt; tuple[ModelPermissionTyping, ModelOperationPermission]:

        # get permission config
        # pass the user id here since we&#39;re trying to get the rows
        permission = permissions.get(role, lambda x: None)(userId)
        permissionError = PermissionError(
            f&#34;User{&#39;({id})&#39;.format({id: userId}) if userId else &#39;&#39;} with role: &#39;{role}&#39; has no {operation} permission&#34;,
            401,
        )

        if not permission:
            raise permissionError

        # operation permission
        operationPermission: ModelOperationPermission | None = permission.get(operation)

        if not operationPermission:
            raise permissionError

        return (permission, operationPermission)

    def find(self, request: Request, args: dict):
        &#34;&#34;&#34;returns a single object from models

        Args:
            request (Request): _description_
            args (dict): _description_

        Raises:
            Interruption: _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        where = args.get(&#34;where&#34;)
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        Sr = self.modelConfig.createSerializerClass(role)

        selectPermission = typing.cast(
            SelectPermissionTyping,
            ModelIntent.getPermission(
                role,
                &#34;select&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            )[1],
        )

        query = makeQuery(where) if where else None

        models = (
            self.modelConfig.model.objects.all()
            if selectPermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
        )

        instance = models.get(query) if query else models.first()
        return Sr(instance).data

    def selectMany(self, request: Request, args: dict):
        &#34;&#34;&#34;Select items of a model.

        Args:
            request (Request): _description_
            args (dict): _description_

        Raises:
            Interruption: _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        where = args.get(&#34;where&#34;)
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        Sr = self.modelConfig.createSerializerClass(role)

        selectPermission = typing.cast(
            SelectPermissionTyping,
            ModelIntent.getPermission(
                role,
                &#34;select&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            )[1],
        )

        query = makeQuery(where) if where else None
        models = (
            self.modelConfig.model.objects.all()
            if selectPermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
        )

        models = models.filter(query) if query else models
        return Sr(models, many=True).data

    def insert(self, request: Request, args: dict[str, typing.Any]):
        obj: dict[str, typing.Any] = args[&#34;object&#34;]  # required

        # get role and permission config
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, insertPermission = typing.cast(
            tuple[ModelPermissionTyping, InsertPermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;insert&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        checkDefault = lambda request, params: True
        insertPermission.setdefault(&#34;check&#34;, checkDefault)
        insertPermission.setdefault(&#34;requiredFields&#34;, [])

        if not insertPermission.get(&#34;check&#34;, checkDefault)(request, obj):
            raise PermissionError(&#34;Unauthorized insertion&#34;, 401)

        # required fields should be a subset of insertable column
        if not (
            insertPermission[&#34;column&#34;] == CellFlags.ALL
            or set(
                typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
            ).issubset(insertPermission[&#34;column&#34;])
        ):
            raise Exception(
                &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
            )

        # check if required field&#39;s in obj
        if not set(
            typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
        ).issubset(obj.keys()):
            raise Exception(
                f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;,
                500,
            )

        # check if user only included permitted colums in obj
        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if insertPermission[&#34;column&#34;] == CellFlags.ALL
            else insertPermission[&#34;column&#34;]
        )

        for key in obj.keys():
            if not (key in fields):
                raise RequestHandlingError(
                    f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                    errorCode=errorConstants.UNKNOWN_ARGS,
                    statusCode=400,
                )

            # foriegn keys need to be passed by object
            # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
            # but book.author has to be an Object not a string. so we check to see if Book config
            # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
            # to it&#39;s respective object
            fk = self.modelConfig.foreignKeys.get(key)
            if fk:
                # if key is a foriegn key, change the string or integer pk to an item
                # that correspond to its model object
                # obj[key] = fk.getObject(obj[key])
                obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

        try:
            # create model
            model = self.modelConfig.model(**obj)
            model.save()

            # get model data from select realizers
            Sr = self.modelConfig.createSerializerClass(role)
            return Sr(model).data

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=400,
            )

    def insertMany(self, request: Request, args: dict):
        objects: list[dict[str, typing.Any]] = args[&#34;objects&#34;]  # required

        # get role and permission config
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        # get insert permission
        _, insertPermission = typing.cast(
            tuple[ModelPermissionTyping, InsertPermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;insert&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        checkDefault = lambda request, params: True
        insertPermission.setdefault(&#34;check&#34;, checkDefault)
        insertPermission.setdefault(&#34;requiredFields&#34;, [])

        if not all(
            [
                insertPermission.get(&#34;check&#34;, checkDefault)(request, param)
                for param in objects
            ]
        ):
            raise PermissionError(&#34;Unauthorised insertion&#34;, 401)

        # get model data from select realizers
        Sr = self.modelConfig.createSerializerClass(role)

        # required fields should be a subset of insertable column
        if not (
            insertPermission[&#34;column&#34;] == CellFlags.ALL
            or set(
                typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
            ).issubset(insertPermission[&#34;column&#34;])
        ):
            raise Exception(
                &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
            )

        # check if required field&#39;s in each object
        if not all(
            [
                set(
                    typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
                ).issubset(obj.keys())
                for obj in objects
            ]
        ):
            raise Exception(
                f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;
            )

        # check if user only included permitted colums in each object
        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if insertPermission[&#34;column&#34;] == CellFlags.ALL
            else insertPermission[&#34;column&#34;]
        )

        res = []  # result

        try:
            with transaction.atomic():
                for obj in objects:
                    for key in obj.keys():
                        if not (key in fields):
                            raise RequestHandlingError(
                                f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                                errorCode=errorConstants.UNKNOWN_ARGS,
                                statusCode=400,
                            )

                        # foriegn keys need to be passed by object
                        # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
                        # but book.author has to be an Object not a string. so we check to see if Book config
                        # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
                        # to it&#39;s respective object
                        fk = self.modelConfig.foreignKeys.get(key)
                        if fk:
                            # if key is a foriegn key, change the string or integer pk to an item
                            # that correspond to its model object
                            obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

                    # create model
                    model = self.modelConfig.model(**obj)
                    model.save()

                    res.append(model)

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=400,
            )

        return Sr(res, many=True).data

    def update(self, request: Request, args):
        args = typing.cast(PartialUpdateTyping, args)
        partial: dict = args[&#34;partial&#34;]  # required
        pk: types.Pk = args[&#34;pk&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, updatePermission = typing.cast(
            tuple[ModelPermissionTyping, UpdatePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;update&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )
        checkDefault = lambda req, partial: True
        updatePermission.setdefault(&#34;check&#34;, checkDefault)

        if not updatePermission.get(&#34;check&#34;, checkDefault)(
            request, {&#34;pk&#34;: pk, &#34;partial&#34;: partial}
        ):
            raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

        Sr = self.modelConfig.createSerializerClass(role)

        # fetch all the rows that can be updated by the client
        models = (
            self.modelConfig.model.objects.all()
            if updatePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
        )

        try:
            obj: Model = models.get(pk=pk)

            # check if user only included permitted colums in obj
            fields = (
                [
                    field.name
                    for field in self.modelConfig.model._meta.get_fields()
                    if isinstance(field, Field)
                ]
                + [fk for fk in self.modelConfig.foreignKeys.keys()]
                if updatePermission[&#34;column&#34;] == CellFlags.ALL
                else updatePermission[&#34;column&#34;]
            )

            for key, value in partial.items():
                if not (key in fields):
                    raise RequestHandlingError(
                        f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                        errorCode=&#34;&#34;,
                        statusCode=400,
                    )

                setattr(obj, key, value)

            obj.save(update_fields=partial.keys())
            return Sr(obj).data

        except BaseException as e:
            _e404 = type(e) == self.modelConfig.model.DoesNotExist

            raise RequestHandlingError(
                f&#34;{self.modelConfig.name}(pk={pk}) not found&#34;
                if _e404
                else e.args[0]
                if len(e.args) &gt; 0
                else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=404 if _e404 else 400,
            )

    def updateMany(self, request: Request, args: dict[str, typing.Any]):
        &#34;&#34;&#34;args[objects] should be a list of objects.
        [{pk: str|int, set: {...}}]
        &#34;&#34;&#34;
        objects: list[PartialUpdateTyping] = args[&#34;objects&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, updatePermission = typing.cast(
            tuple[ModelPermissionTyping, UpdatePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;update&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )
        checkDefault = lambda req, partialUpdate: True
        updatePermission.setdefault(&#34;check&#34;, checkDefault)

        if not all(
            [
                updatePermission.get(&#34;check&#34;, checkDefault)(request, partialUpdate)
                for partialUpdate in objects
            ]
        ):
            raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

        Sr = self.modelConfig.createSerializerClass(role)

        models = (
            self.modelConfig.model.objects.all()
            if updatePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
        )

        res = []  # result

        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if updatePermission[&#34;column&#34;] == CellFlags.ALL
            else updatePermission[&#34;column&#34;]
        )

        try:
            with transaction.atomic():
                for unit in objects:
                    pk = unit[&#34;pk&#34;]  # required
                    partialUpdate = unit[&#34;partial&#34;]  # required

                    obj: Model = models.get(pk=pk)

                    # check if user only included permitted colums in obj

                    for key, value in partialUpdate.items():
                        if not (key in fields):
                            raise RequestHandlingError(
                                f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                                errorCode=&#34;&#34;,
                                statusCode=400,
                            )

                        setattr(obj, key, value)

                    obj.save(update_fields=partialUpdate.keys())
                    res.append(obj)

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=404
                if type(e) == self.modelConfig.model.DoesNotExist
                else 400,
            )

        return Sr(res, many=True).data

    def delete(self, request: Request, args: dict):
        pk: types.Pk = args[&#34;pk&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        _, deletePermission = typing.cast(
            tuple[ModelPermissionTyping, DeletePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;delete&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        models = (
            self.modelConfig.model.objects.all()
            if deletePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
        )

        try:
            obj: Model = models.get(pk=pk)
            obj.delete()
            return None
        except self.modelConfig.model.DoesNotExist:
            raise RequestHandlingError(
                &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
            )

    def deleteMany(self, request: Request, args: dict):
        pks: list[types.Pk] = args[&#34;pks&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        _, deletePermission = typing.cast(
            tuple[ModelPermissionTyping, DeletePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;delete&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        models = (
            self.modelConfig.model.objects.all()
            if deletePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
        )

        try:
            with transaction.atomic():
                instances: list[Model] = [models.get(pk=pk) for pk in pks]
                for instance in instances:
                    instance.delete()
            return None
        except self.modelConfig.model.DoesNotExist:
            raise RequestHandlingError(
                &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
            )

    # TODO: ...
    def deleteWhere(self, request: Request, args: dict[str, typing.Any]):
        &#34;&#34;&#34;TODO: delete a set of rows that match the where query&#34;&#34;&#34;
        ...

    @property
    def intenthandlers(self) -&gt; dict[str, IntentFunction]:
        name = self.modelConfig.name

        rel = {
            ModelOperations.SELECT_ONE: (
                f&#34;models.{name}.find&#34;,
                IntentFunction(self.find, requiredArgs=(&#34;where&#34;,)),
            ),
            ModelOperations.SELECT_MANY: (
                f&#34;models.{name}.selectmany&#34;,
                IntentFunction(self.selectMany, optionalArgs=(&#34;where&#34;,)),
            ),
            ModelOperations.INSERT: (
                f&#34;models.{name}.insert&#34;,
                IntentFunction(self.insert, requiredArgs=(&#34;object&#34;,)),
            ),
            ModelOperations.INSERT_MANY: (
                f&#34;models.{name}.insertmany&#34;,
                IntentFunction(
                    self.insertMany,
                    requiredArgs=(&#34;objects&#34;,),
                ),
            ),
            ModelOperations.UPDATE: (
                f&#34;models.{name}.update&#34;,
                IntentFunction(self.update, requiredArgs=(&#34;pk&#34;, &#34;partial&#34;)),
            ),
            ModelOperations.UPDATE_MANY: (
                f&#34;models.{name}.updatemany&#34;,
                IntentFunction(self.updateMany, requiredArgs=(&#34;objects&#34;,)),
            ),
            ModelOperations.DELETE: (
                f&#34;models.{name}.delete&#34;,
                IntentFunction(self.delete, requiredArgs=(&#34;pk&#34;,)),
            ),
            ModelOperations.DELETE_MANY: (
                f&#34;models.{name}.deletemany&#34;,
                IntentFunction(self.delete, requiredArgs=(&#34;pks&#34;,)),
            ),
        }

        # filter functions to publish based on configuration
        for i in [*rel.keys()]:
            if not (i in self.modelConfig.allowedOperations):
                del rel[i]

        return dict([pair for pair in rel.values()])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uql.intent.model.ModelIntent"><code class="flex name class">
<span>class <span class="ident">ModelIntent</span></span>
<span>(</span><span>rootConfig: type[<a title="uql.config.UQLConfig" href="../config.html#uql.config.UQLConfig">UQLConfig</a>], modelConfig: <a title="uql.model.ModelConfig" href="../model.html#uql.model.ModelConfig">ModelConfig</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelIntent:
    def __init__(self, rootConfig: type[UQLConfig], modelConfig: ModelConfig) -&gt; None:
        self.modelConfig = modelConfig
        self.rootConfig = rootConfig

    @staticmethod
    def getUserIdFromRequest(request: Request) -&gt; types.Pk | None:
        return getattr(request.user, &#34;id&#34;, None)

    @staticmethod
    def getPermission(
        role: str,
        operation: ModelOperationKeys,
        permissions: dict[
            str, typing.Callable[[types.Pk | None], ModelPermissionTyping]
        ],
        userId: str | int | None = None,
    ) -&gt; tuple[ModelPermissionTyping, ModelOperationPermission]:

        # get permission config
        # pass the user id here since we&#39;re trying to get the rows
        permission = permissions.get(role, lambda x: None)(userId)
        permissionError = PermissionError(
            f&#34;User{&#39;({id})&#39;.format({id: userId}) if userId else &#39;&#39;} with role: &#39;{role}&#39; has no {operation} permission&#34;,
            401,
        )

        if not permission:
            raise permissionError

        # operation permission
        operationPermission: ModelOperationPermission | None = permission.get(operation)

        if not operationPermission:
            raise permissionError

        return (permission, operationPermission)

    def find(self, request: Request, args: dict):
        &#34;&#34;&#34;returns a single object from models

        Args:
            request (Request): _description_
            args (dict): _description_

        Raises:
            Interruption: _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        where = args.get(&#34;where&#34;)
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        Sr = self.modelConfig.createSerializerClass(role)

        selectPermission = typing.cast(
            SelectPermissionTyping,
            ModelIntent.getPermission(
                role,
                &#34;select&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            )[1],
        )

        query = makeQuery(where) if where else None

        models = (
            self.modelConfig.model.objects.all()
            if selectPermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
        )

        instance = models.get(query) if query else models.first()
        return Sr(instance).data

    def selectMany(self, request: Request, args: dict):
        &#34;&#34;&#34;Select items of a model.

        Args:
            request (Request): _description_
            args (dict): _description_

        Raises:
            Interruption: _description_

        Returns:
            _type_: _description_
        &#34;&#34;&#34;
        where = args.get(&#34;where&#34;)
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        Sr = self.modelConfig.createSerializerClass(role)

        selectPermission = typing.cast(
            SelectPermissionTyping,
            ModelIntent.getPermission(
                role,
                &#34;select&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            )[1],
        )

        query = makeQuery(where) if where else None
        models = (
            self.modelConfig.model.objects.all()
            if selectPermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
        )

        models = models.filter(query) if query else models
        return Sr(models, many=True).data

    def insert(self, request: Request, args: dict[str, typing.Any]):
        obj: dict[str, typing.Any] = args[&#34;object&#34;]  # required

        # get role and permission config
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, insertPermission = typing.cast(
            tuple[ModelPermissionTyping, InsertPermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;insert&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        checkDefault = lambda request, params: True
        insertPermission.setdefault(&#34;check&#34;, checkDefault)
        insertPermission.setdefault(&#34;requiredFields&#34;, [])

        if not insertPermission.get(&#34;check&#34;, checkDefault)(request, obj):
            raise PermissionError(&#34;Unauthorized insertion&#34;, 401)

        # required fields should be a subset of insertable column
        if not (
            insertPermission[&#34;column&#34;] == CellFlags.ALL
            or set(
                typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
            ).issubset(insertPermission[&#34;column&#34;])
        ):
            raise Exception(
                &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
            )

        # check if required field&#39;s in obj
        if not set(
            typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
        ).issubset(obj.keys()):
            raise Exception(
                f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;,
                500,
            )

        # check if user only included permitted colums in obj
        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if insertPermission[&#34;column&#34;] == CellFlags.ALL
            else insertPermission[&#34;column&#34;]
        )

        for key in obj.keys():
            if not (key in fields):
                raise RequestHandlingError(
                    f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                    errorCode=errorConstants.UNKNOWN_ARGS,
                    statusCode=400,
                )

            # foriegn keys need to be passed by object
            # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
            # but book.author has to be an Object not a string. so we check to see if Book config
            # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
            # to it&#39;s respective object
            fk = self.modelConfig.foreignKeys.get(key)
            if fk:
                # if key is a foriegn key, change the string or integer pk to an item
                # that correspond to its model object
                # obj[key] = fk.getObject(obj[key])
                obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

        try:
            # create model
            model = self.modelConfig.model(**obj)
            model.save()

            # get model data from select realizers
            Sr = self.modelConfig.createSerializerClass(role)
            return Sr(model).data

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=400,
            )

    def insertMany(self, request: Request, args: dict):
        objects: list[dict[str, typing.Any]] = args[&#34;objects&#34;]  # required

        # get role and permission config
        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        # get insert permission
        _, insertPermission = typing.cast(
            tuple[ModelPermissionTyping, InsertPermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;insert&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        checkDefault = lambda request, params: True
        insertPermission.setdefault(&#34;check&#34;, checkDefault)
        insertPermission.setdefault(&#34;requiredFields&#34;, [])

        if not all(
            [
                insertPermission.get(&#34;check&#34;, checkDefault)(request, param)
                for param in objects
            ]
        ):
            raise PermissionError(&#34;Unauthorised insertion&#34;, 401)

        # get model data from select realizers
        Sr = self.modelConfig.createSerializerClass(role)

        # required fields should be a subset of insertable column
        if not (
            insertPermission[&#34;column&#34;] == CellFlags.ALL
            or set(
                typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
            ).issubset(insertPermission[&#34;column&#34;])
        ):
            raise Exception(
                &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
            )

        # check if required field&#39;s in each object
        if not all(
            [
                set(
                    typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
                ).issubset(obj.keys())
                for obj in objects
            ]
        ):
            raise Exception(
                f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;
            )

        # check if user only included permitted colums in each object
        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if insertPermission[&#34;column&#34;] == CellFlags.ALL
            else insertPermission[&#34;column&#34;]
        )

        res = []  # result

        try:
            with transaction.atomic():
                for obj in objects:
                    for key in obj.keys():
                        if not (key in fields):
                            raise RequestHandlingError(
                                f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                                errorCode=errorConstants.UNKNOWN_ARGS,
                                statusCode=400,
                            )

                        # foriegn keys need to be passed by object
                        # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
                        # but book.author has to be an Object not a string. so we check to see if Book config
                        # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
                        # to it&#39;s respective object
                        fk = self.modelConfig.foreignKeys.get(key)
                        if fk:
                            # if key is a foriegn key, change the string or integer pk to an item
                            # that correspond to its model object
                            obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

                    # create model
                    model = self.modelConfig.model(**obj)
                    model.save()

                    res.append(model)

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=400,
            )

        return Sr(res, many=True).data

    def update(self, request: Request, args):
        args = typing.cast(PartialUpdateTyping, args)
        partial: dict = args[&#34;partial&#34;]  # required
        pk: types.Pk = args[&#34;pk&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, updatePermission = typing.cast(
            tuple[ModelPermissionTyping, UpdatePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;update&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )
        checkDefault = lambda req, partial: True
        updatePermission.setdefault(&#34;check&#34;, checkDefault)

        if not updatePermission.get(&#34;check&#34;, checkDefault)(
            request, {&#34;pk&#34;: pk, &#34;partial&#34;: partial}
        ):
            raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

        Sr = self.modelConfig.createSerializerClass(role)

        # fetch all the rows that can be updated by the client
        models = (
            self.modelConfig.model.objects.all()
            if updatePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
        )

        try:
            obj: Model = models.get(pk=pk)

            # check if user only included permitted colums in obj
            fields = (
                [
                    field.name
                    for field in self.modelConfig.model._meta.get_fields()
                    if isinstance(field, Field)
                ]
                + [fk for fk in self.modelConfig.foreignKeys.keys()]
                if updatePermission[&#34;column&#34;] == CellFlags.ALL
                else updatePermission[&#34;column&#34;]
            )

            for key, value in partial.items():
                if not (key in fields):
                    raise RequestHandlingError(
                        f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                        errorCode=&#34;&#34;,
                        statusCode=400,
                    )

                setattr(obj, key, value)

            obj.save(update_fields=partial.keys())
            return Sr(obj).data

        except BaseException as e:
            _e404 = type(e) == self.modelConfig.model.DoesNotExist

            raise RequestHandlingError(
                f&#34;{self.modelConfig.name}(pk={pk}) not found&#34;
                if _e404
                else e.args[0]
                if len(e.args) &gt; 0
                else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=404 if _e404 else 400,
            )

    def updateMany(self, request: Request, args: dict[str, typing.Any]):
        &#34;&#34;&#34;args[objects] should be a list of objects.
        [{pk: str|int, set: {...}}]
        &#34;&#34;&#34;
        objects: list[PartialUpdateTyping] = args[&#34;objects&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)

        _, updatePermission = typing.cast(
            tuple[ModelPermissionTyping, UpdatePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;update&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )
        checkDefault = lambda req, partialUpdate: True
        updatePermission.setdefault(&#34;check&#34;, checkDefault)

        if not all(
            [
                updatePermission.get(&#34;check&#34;, checkDefault)(request, partialUpdate)
                for partialUpdate in objects
            ]
        ):
            raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

        Sr = self.modelConfig.createSerializerClass(role)

        models = (
            self.modelConfig.model.objects.all()
            if updatePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
        )

        res = []  # result

        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if updatePermission[&#34;column&#34;] == CellFlags.ALL
            else updatePermission[&#34;column&#34;]
        )

        try:
            with transaction.atomic():
                for unit in objects:
                    pk = unit[&#34;pk&#34;]  # required
                    partialUpdate = unit[&#34;partial&#34;]  # required

                    obj: Model = models.get(pk=pk)

                    # check if user only included permitted colums in obj

                    for key, value in partialUpdate.items():
                        if not (key in fields):
                            raise RequestHandlingError(
                                f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                                errorCode=&#34;&#34;,
                                statusCode=400,
                            )

                        setattr(obj, key, value)

                    obj.save(update_fields=partialUpdate.keys())
                    res.append(obj)

        except BaseException as e:
            raise RequestHandlingError(
                e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
                errorCode=e.__class__.__name__,
                statusCode=404
                if type(e) == self.modelConfig.model.DoesNotExist
                else 400,
            )

        return Sr(res, many=True).data

    def delete(self, request: Request, args: dict):
        pk: types.Pk = args[&#34;pk&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        _, deletePermission = typing.cast(
            tuple[ModelPermissionTyping, DeletePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;delete&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        models = (
            self.modelConfig.model.objects.all()
            if deletePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
        )

        try:
            obj: Model = models.get(pk=pk)
            obj.delete()
            return None
        except self.modelConfig.model.DoesNotExist:
            raise RequestHandlingError(
                &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
            )

    def deleteMany(self, request: Request, args: dict):
        pks: list[types.Pk] = args[&#34;pks&#34;]  # required

        role = self.rootConfig.getAuthenticatedUserRoles(request.user)
        _, deletePermission = typing.cast(
            tuple[ModelPermissionTyping, DeletePermissionTyping],
            ModelIntent.getPermission(
                role,
                &#34;delete&#34;,
                self.modelConfig.permissions,
                ModelIntent.getUserIdFromRequest(request),
            ),
        )

        models = (
            self.modelConfig.model.objects.all()
            if deletePermission[&#34;row&#34;] == CellFlags.ALL
            else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
        )

        try:
            with transaction.atomic():
                instances: list[Model] = [models.get(pk=pk) for pk in pks]
                for instance in instances:
                    instance.delete()
            return None
        except self.modelConfig.model.DoesNotExist:
            raise RequestHandlingError(
                &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
            )

    # TODO: ...
    def deleteWhere(self, request: Request, args: dict[str, typing.Any]):
        &#34;&#34;&#34;TODO: delete a set of rows that match the where query&#34;&#34;&#34;
        ...

    @property
    def intenthandlers(self) -&gt; dict[str, IntentFunction]:
        name = self.modelConfig.name

        rel = {
            ModelOperations.SELECT_ONE: (
                f&#34;models.{name}.find&#34;,
                IntentFunction(self.find, requiredArgs=(&#34;where&#34;,)),
            ),
            ModelOperations.SELECT_MANY: (
                f&#34;models.{name}.selectmany&#34;,
                IntentFunction(self.selectMany, optionalArgs=(&#34;where&#34;,)),
            ),
            ModelOperations.INSERT: (
                f&#34;models.{name}.insert&#34;,
                IntentFunction(self.insert, requiredArgs=(&#34;object&#34;,)),
            ),
            ModelOperations.INSERT_MANY: (
                f&#34;models.{name}.insertmany&#34;,
                IntentFunction(
                    self.insertMany,
                    requiredArgs=(&#34;objects&#34;,),
                ),
            ),
            ModelOperations.UPDATE: (
                f&#34;models.{name}.update&#34;,
                IntentFunction(self.update, requiredArgs=(&#34;pk&#34;, &#34;partial&#34;)),
            ),
            ModelOperations.UPDATE_MANY: (
                f&#34;models.{name}.updatemany&#34;,
                IntentFunction(self.updateMany, requiredArgs=(&#34;objects&#34;,)),
            ),
            ModelOperations.DELETE: (
                f&#34;models.{name}.delete&#34;,
                IntentFunction(self.delete, requiredArgs=(&#34;pk&#34;,)),
            ),
            ModelOperations.DELETE_MANY: (
                f&#34;models.{name}.deletemany&#34;,
                IntentFunction(self.delete, requiredArgs=(&#34;pks&#34;,)),
            ),
        }

        # filter functions to publish based on configuration
        for i in [*rel.keys()]:
            if not (i in self.modelConfig.allowedOperations):
                del rel[i]

        return dict([pair for pair in rel.values()])</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="uql.intent.model.ModelIntent.getPermission"><code class="name flex">
<span>def <span class="ident">getPermission</span></span>(<span>role: str, operation: Union[Literal['select'], Literal['insert'], Literal['update'], Literal['delete']], permissions: dict[str, typing.Callable[[int | str | None], <a title="uql.model.ModelPermissionTyping" href="../model.html#uql.model.ModelPermissionTyping">ModelPermissionTyping</a>]], userId: int | str | None = None) ‑> tuple[<a title="uql.model.ModelPermissionTyping" href="../model.html#uql.model.ModelPermissionTyping">ModelPermissionTyping</a>, <a title="uql.model.SelectPermissionTyping" href="../model.html#uql.model.SelectPermissionTyping">SelectPermissionTyping</a> | <a title="uql.model.UpdatePermissionTyping" href="../model.html#uql.model.UpdatePermissionTyping">UpdatePermissionTyping</a> | <a title="uql.model.InsertPermissionTyping" href="../model.html#uql.model.InsertPermissionTyping">InsertPermissionTyping</a> | <a title="uql.model.DeletePermissionTyping" href="../model.html#uql.model.DeletePermissionTyping">DeletePermissionTyping</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getPermission(
    role: str,
    operation: ModelOperationKeys,
    permissions: dict[
        str, typing.Callable[[types.Pk | None], ModelPermissionTyping]
    ],
    userId: str | int | None = None,
) -&gt; tuple[ModelPermissionTyping, ModelOperationPermission]:

    # get permission config
    # pass the user id here since we&#39;re trying to get the rows
    permission = permissions.get(role, lambda x: None)(userId)
    permissionError = PermissionError(
        f&#34;User{&#39;({id})&#39;.format({id: userId}) if userId else &#39;&#39;} with role: &#39;{role}&#39; has no {operation} permission&#34;,
        401,
    )

    if not permission:
        raise permissionError

    # operation permission
    operationPermission: ModelOperationPermission | None = permission.get(operation)

    if not operationPermission:
        raise permissionError

    return (permission, operationPermission)</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.getUserIdFromRequest"><code class="name flex">
<span>def <span class="ident">getUserIdFromRequest</span></span>(<span>request: rest_framework.request.Request) ‑> int | str | None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getUserIdFromRequest(request: Request) -&gt; types.Pk | None:
    return getattr(request.user, &#34;id&#34;, None)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uql.intent.model.ModelIntent.intenthandlers"><code class="name">var <span class="ident">intenthandlers</span> : dict[str, <a title="uql.intent.IntentFunction" href="index.html#uql.intent.IntentFunction">IntentFunction</a>]</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def intenthandlers(self) -&gt; dict[str, IntentFunction]:
    name = self.modelConfig.name

    rel = {
        ModelOperations.SELECT_ONE: (
            f&#34;models.{name}.find&#34;,
            IntentFunction(self.find, requiredArgs=(&#34;where&#34;,)),
        ),
        ModelOperations.SELECT_MANY: (
            f&#34;models.{name}.selectmany&#34;,
            IntentFunction(self.selectMany, optionalArgs=(&#34;where&#34;,)),
        ),
        ModelOperations.INSERT: (
            f&#34;models.{name}.insert&#34;,
            IntentFunction(self.insert, requiredArgs=(&#34;object&#34;,)),
        ),
        ModelOperations.INSERT_MANY: (
            f&#34;models.{name}.insertmany&#34;,
            IntentFunction(
                self.insertMany,
                requiredArgs=(&#34;objects&#34;,),
            ),
        ),
        ModelOperations.UPDATE: (
            f&#34;models.{name}.update&#34;,
            IntentFunction(self.update, requiredArgs=(&#34;pk&#34;, &#34;partial&#34;)),
        ),
        ModelOperations.UPDATE_MANY: (
            f&#34;models.{name}.updatemany&#34;,
            IntentFunction(self.updateMany, requiredArgs=(&#34;objects&#34;,)),
        ),
        ModelOperations.DELETE: (
            f&#34;models.{name}.delete&#34;,
            IntentFunction(self.delete, requiredArgs=(&#34;pk&#34;,)),
        ),
        ModelOperations.DELETE_MANY: (
            f&#34;models.{name}.deletemany&#34;,
            IntentFunction(self.delete, requiredArgs=(&#34;pks&#34;,)),
        ),
    }

    # filter functions to publish based on configuration
    for i in [*rel.keys()]:
        if not (i in self.modelConfig.allowedOperations):
            del rel[i]

    return dict([pair for pair in rel.values()])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uql.intent.model.ModelIntent.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, request: rest_framework.request.Request, args: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete(self, request: Request, args: dict):
    pk: types.Pk = args[&#34;pk&#34;]  # required

    role = self.rootConfig.getAuthenticatedUserRoles(request.user)
    _, deletePermission = typing.cast(
        tuple[ModelPermissionTyping, DeletePermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;delete&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )

    models = (
        self.modelConfig.model.objects.all()
        if deletePermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
    )

    try:
        obj: Model = models.get(pk=pk)
        obj.delete()
        return None
    except self.modelConfig.model.DoesNotExist:
        raise RequestHandlingError(
            &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
        )</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.deleteMany"><code class="name flex">
<span>def <span class="ident">deleteMany</span></span>(<span>self, request: rest_framework.request.Request, args: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteMany(self, request: Request, args: dict):
    pks: list[types.Pk] = args[&#34;pks&#34;]  # required

    role = self.rootConfig.getAuthenticatedUserRoles(request.user)
    _, deletePermission = typing.cast(
        tuple[ModelPermissionTyping, DeletePermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;delete&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )

    models = (
        self.modelConfig.model.objects.all()
        if deletePermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(deletePermission[&#34;row&#34;])
    )

    try:
        with transaction.atomic():
            instances: list[Model] = [models.get(pk=pk) for pk in pks]
            for instance in instances:
                instance.delete()
        return None
    except self.modelConfig.model.DoesNotExist:
        raise RequestHandlingError(
            &#34;&#34;, errorCode=errorConstants.OBJECT_NOT_FOUND, statusCode=404
        )</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.deleteWhere"><code class="name flex">
<span>def <span class="ident">deleteWhere</span></span>(<span>self, request: rest_framework.request.Request, args: dict[str, typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>TODO: delete a set of rows that match the where query</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def deleteWhere(self, request: Request, args: dict[str, typing.Any]):
    &#34;&#34;&#34;TODO: delete a set of rows that match the where query&#34;&#34;&#34;
    ...</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.find"><code class="name flex">
<span>def <span class="ident">find</span></span>(<span>self, request: rest_framework.request.Request, args: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>returns a single object from models</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Interruption</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find(self, request: Request, args: dict):
    &#34;&#34;&#34;returns a single object from models

    Args:
        request (Request): _description_
        args (dict): _description_

    Raises:
        Interruption: _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    where = args.get(&#34;where&#34;)
    role = self.rootConfig.getAuthenticatedUserRoles(request.user)
    Sr = self.modelConfig.createSerializerClass(role)

    selectPermission = typing.cast(
        SelectPermissionTyping,
        ModelIntent.getPermission(
            role,
            &#34;select&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        )[1],
    )

    query = makeQuery(where) if where else None

    models = (
        self.modelConfig.model.objects.all()
        if selectPermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
    )

    instance = models.get(query) if query else models.first()
    return Sr(instance).data</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.insert"><code class="name flex">
<span>def <span class="ident">insert</span></span>(<span>self, request: rest_framework.request.Request, args: dict[str, typing.Any])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insert(self, request: Request, args: dict[str, typing.Any]):
    obj: dict[str, typing.Any] = args[&#34;object&#34;]  # required

    # get role and permission config
    role = self.rootConfig.getAuthenticatedUserRoles(request.user)

    _, insertPermission = typing.cast(
        tuple[ModelPermissionTyping, InsertPermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;insert&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )

    checkDefault = lambda request, params: True
    insertPermission.setdefault(&#34;check&#34;, checkDefault)
    insertPermission.setdefault(&#34;requiredFields&#34;, [])

    if not insertPermission.get(&#34;check&#34;, checkDefault)(request, obj):
        raise PermissionError(&#34;Unauthorized insertion&#34;, 401)

    # required fields should be a subset of insertable column
    if not (
        insertPermission[&#34;column&#34;] == CellFlags.ALL
        or set(
            typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
        ).issubset(insertPermission[&#34;column&#34;])
    ):
        raise Exception(
            &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
        )

    # check if required field&#39;s in obj
    if not set(
        typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
    ).issubset(obj.keys()):
        raise Exception(
            f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;,
            500,
        )

    # check if user only included permitted colums in obj
    fields = (
        [
            field.name
            for field in self.modelConfig.model._meta.get_fields()
            if isinstance(field, Field)
        ]
        + [fk for fk in self.modelConfig.foreignKeys.keys()]
        if insertPermission[&#34;column&#34;] == CellFlags.ALL
        else insertPermission[&#34;column&#34;]
    )

    for key in obj.keys():
        if not (key in fields):
            raise RequestHandlingError(
                f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                errorCode=errorConstants.UNKNOWN_ARGS,
                statusCode=400,
            )

        # foriegn keys need to be passed by object
        # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
        # but book.author has to be an Object not a string. so we check to see if Book config
        # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
        # to it&#39;s respective object
        fk = self.modelConfig.foreignKeys.get(key)
        if fk:
            # if key is a foriegn key, change the string or integer pk to an item
            # that correspond to its model object
            # obj[key] = fk.getObject(obj[key])
            obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

    try:
        # create model
        model = self.modelConfig.model(**obj)
        model.save()

        # get model data from select realizers
        Sr = self.modelConfig.createSerializerClass(role)
        return Sr(model).data

    except BaseException as e:
        raise RequestHandlingError(
            e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
            errorCode=e.__class__.__name__,
            statusCode=400,
        )</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.insertMany"><code class="name flex">
<span>def <span class="ident">insertMany</span></span>(<span>self, request: rest_framework.request.Request, args: dict)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def insertMany(self, request: Request, args: dict):
    objects: list[dict[str, typing.Any]] = args[&#34;objects&#34;]  # required

    # get role and permission config
    role = self.rootConfig.getAuthenticatedUserRoles(request.user)

    # get insert permission
    _, insertPermission = typing.cast(
        tuple[ModelPermissionTyping, InsertPermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;insert&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )

    checkDefault = lambda request, params: True
    insertPermission.setdefault(&#34;check&#34;, checkDefault)
    insertPermission.setdefault(&#34;requiredFields&#34;, [])

    if not all(
        [
            insertPermission.get(&#34;check&#34;, checkDefault)(request, param)
            for param in objects
        ]
    ):
        raise PermissionError(&#34;Unauthorised insertion&#34;, 401)

    # get model data from select realizers
    Sr = self.modelConfig.createSerializerClass(role)

    # required fields should be a subset of insertable column
    if not (
        insertPermission[&#34;column&#34;] == CellFlags.ALL
        or set(
            typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
        ).issubset(insertPermission[&#34;column&#34;])
    ):
        raise Exception(
            &#34;insert.requiredFields should be a subset of insert.columns&#34;, 500
        )

    # check if required field&#39;s in each object
    if not all(
        [
            set(
                typing.cast(list[str], insertPermission.get(&#34;requiredFields&#34;))
            ).issubset(obj.keys())
            for obj in objects
        ]
    ):
        raise Exception(
            f&#34;requires fields ({&#39;, &#39;.join(typing.cast(list[str], insertPermission.get(&#39;requiredFields&#39;)))})&#34;
        )

    # check if user only included permitted colums in each object
    fields = (
        [
            field.name
            for field in self.modelConfig.model._meta.get_fields()
            if isinstance(field, Field)
        ]
        + [fk for fk in self.modelConfig.foreignKeys.keys()]
        if insertPermission[&#34;column&#34;] == CellFlags.ALL
        else insertPermission[&#34;column&#34;]
    )

    res = []  # result

    try:
        with transaction.atomic():
            for obj in objects:
                for key in obj.keys():
                    if not (key in fields):
                        raise RequestHandlingError(
                            f&#39;cannot insert &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                            errorCode=errorConstants.UNKNOWN_ARGS,
                            statusCode=400,
                        )

                    # foriegn keys need to be passed by object
                    # we might have an input that tries to insert author=&#34;author-pk&#34; in Book modek
                    # but book.author has to be an Object not a string. so we check to see if Book config
                    # has any foriegn key config attached names author, then we map &#34;author-pk&#34;...
                    # to it&#39;s respective object
                    fk = self.modelConfig.foreignKeys.get(key)
                    if fk:
                        # if key is a foriegn key, change the string or integer pk to an item
                        # that correspond to its model object
                        obj[key] = fk[&#34;model&#34;].objects.get(obj[key])

                # create model
                model = self.modelConfig.model(**obj)
                model.save()

                res.append(model)

    except BaseException as e:
        raise RequestHandlingError(
            e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
            errorCode=e.__class__.__name__,
            statusCode=400,
        )

    return Sr(res, many=True).data</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.selectMany"><code class="name flex">
<span>def <span class="ident">selectMany</span></span>(<span>self, request: rest_framework.request.Request, args: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Select items of a model.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>request</code></strong> :&ensp;<code>Request</code></dt>
<dd><em>description</em></dd>
<dt><strong><code>args</code></strong> :&ensp;<code>dict</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>Interruption</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectMany(self, request: Request, args: dict):
    &#34;&#34;&#34;Select items of a model.

    Args:
        request (Request): _description_
        args (dict): _description_

    Raises:
        Interruption: _description_

    Returns:
        _type_: _description_
    &#34;&#34;&#34;
    where = args.get(&#34;where&#34;)
    role = self.rootConfig.getAuthenticatedUserRoles(request.user)
    Sr = self.modelConfig.createSerializerClass(role)

    selectPermission = typing.cast(
        SelectPermissionTyping,
        ModelIntent.getPermission(
            role,
            &#34;select&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        )[1],
    )

    query = makeQuery(where) if where else None
    models = (
        self.modelConfig.model.objects.all()
        if selectPermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(selectPermission[&#34;row&#34;])
    )

    models = models.filter(query) if query else models
    return Sr(models, many=True).data</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, request: rest_framework.request.Request, args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, request: Request, args):
    args = typing.cast(PartialUpdateTyping, args)
    partial: dict = args[&#34;partial&#34;]  # required
    pk: types.Pk = args[&#34;pk&#34;]  # required

    role = self.rootConfig.getAuthenticatedUserRoles(request.user)

    _, updatePermission = typing.cast(
        tuple[ModelPermissionTyping, UpdatePermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;update&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )
    checkDefault = lambda req, partial: True
    updatePermission.setdefault(&#34;check&#34;, checkDefault)

    if not updatePermission.get(&#34;check&#34;, checkDefault)(
        request, {&#34;pk&#34;: pk, &#34;partial&#34;: partial}
    ):
        raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

    Sr = self.modelConfig.createSerializerClass(role)

    # fetch all the rows that can be updated by the client
    models = (
        self.modelConfig.model.objects.all()
        if updatePermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
    )

    try:
        obj: Model = models.get(pk=pk)

        # check if user only included permitted colums in obj
        fields = (
            [
                field.name
                for field in self.modelConfig.model._meta.get_fields()
                if isinstance(field, Field)
            ]
            + [fk for fk in self.modelConfig.foreignKeys.keys()]
            if updatePermission[&#34;column&#34;] == CellFlags.ALL
            else updatePermission[&#34;column&#34;]
        )

        for key, value in partial.items():
            if not (key in fields):
                raise RequestHandlingError(
                    f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                    errorCode=&#34;&#34;,
                    statusCode=400,
                )

            setattr(obj, key, value)

        obj.save(update_fields=partial.keys())
        return Sr(obj).data

    except BaseException as e:
        _e404 = type(e) == self.modelConfig.model.DoesNotExist

        raise RequestHandlingError(
            f&#34;{self.modelConfig.name}(pk={pk}) not found&#34;
            if _e404
            else e.args[0]
            if len(e.args) &gt; 0
            else &#34;Unknown error&#34;,
            errorCode=e.__class__.__name__,
            statusCode=404 if _e404 else 400,
        )</code></pre>
</details>
</dd>
<dt id="uql.intent.model.ModelIntent.updateMany"><code class="name flex">
<span>def <span class="ident">updateMany</span></span>(<span>self, request: rest_framework.request.Request, args: dict[str, typing.Any])</span>
</code></dt>
<dd>
<div class="desc"><p>args[objects] should be a list of objects.
[{pk: str|int, set: {&hellip;}}]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def updateMany(self, request: Request, args: dict[str, typing.Any]):
    &#34;&#34;&#34;args[objects] should be a list of objects.
    [{pk: str|int, set: {...}}]
    &#34;&#34;&#34;
    objects: list[PartialUpdateTyping] = args[&#34;objects&#34;]  # required

    role = self.rootConfig.getAuthenticatedUserRoles(request.user)

    _, updatePermission = typing.cast(
        tuple[ModelPermissionTyping, UpdatePermissionTyping],
        ModelIntent.getPermission(
            role,
            &#34;update&#34;,
            self.modelConfig.permissions,
            ModelIntent.getUserIdFromRequest(request),
        ),
    )
    checkDefault = lambda req, partialUpdate: True
    updatePermission.setdefault(&#34;check&#34;, checkDefault)

    if not all(
        [
            updatePermission.get(&#34;check&#34;, checkDefault)(request, partialUpdate)
            for partialUpdate in objects
        ]
    ):
        raise PermissionError(&#34;Unauthorized mutation&#34;, 401)

    Sr = self.modelConfig.createSerializerClass(role)

    models = (
        self.modelConfig.model.objects.all()
        if updatePermission[&#34;row&#34;] == CellFlags.ALL
        else self.modelConfig.model.objects.filter(updatePermission[&#34;row&#34;])
    )

    res = []  # result

    fields = (
        [
            field.name
            for field in self.modelConfig.model._meta.get_fields()
            if isinstance(field, Field)
        ]
        + [fk for fk in self.modelConfig.foreignKeys.keys()]
        if updatePermission[&#34;column&#34;] == CellFlags.ALL
        else updatePermission[&#34;column&#34;]
    )

    try:
        with transaction.atomic():
            for unit in objects:
                pk = unit[&#34;pk&#34;]  # required
                partialUpdate = unit[&#34;partial&#34;]  # required

                obj: Model = models.get(pk=pk)

                # check if user only included permitted colums in obj

                for key, value in partialUpdate.items():
                    if not (key in fields):
                        raise RequestHandlingError(
                            f&#39;cannot update &#34;{key}&#34; in {self.modelConfig.name}&#39;,
                            errorCode=&#34;&#34;,
                            statusCode=400,
                        )

                    setattr(obj, key, value)

                obj.save(update_fields=partialUpdate.keys())
                res.append(obj)

    except BaseException as e:
        raise RequestHandlingError(
            e.args[0] if len(e.args) &gt; 0 else &#34;Unknown error&#34;,
            errorCode=e.__class__.__name__,
            statusCode=404
            if type(e) == self.modelConfig.model.DoesNotExist
            else 400,
        )

    return Sr(res, many=True).data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uql.intent" href="index.html">uql.intent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uql.intent.model.ModelIntent" href="#uql.intent.model.ModelIntent">ModelIntent</a></code></h4>
<ul class="">
<li><code><a title="uql.intent.model.ModelIntent.delete" href="#uql.intent.model.ModelIntent.delete">delete</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.deleteMany" href="#uql.intent.model.ModelIntent.deleteMany">deleteMany</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.deleteWhere" href="#uql.intent.model.ModelIntent.deleteWhere">deleteWhere</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.find" href="#uql.intent.model.ModelIntent.find">find</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.getPermission" href="#uql.intent.model.ModelIntent.getPermission">getPermission</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.getUserIdFromRequest" href="#uql.intent.model.ModelIntent.getUserIdFromRequest">getUserIdFromRequest</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.insert" href="#uql.intent.model.ModelIntent.insert">insert</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.insertMany" href="#uql.intent.model.ModelIntent.insertMany">insertMany</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.intenthandlers" href="#uql.intent.model.ModelIntent.intenthandlers">intenthandlers</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.selectMany" href="#uql.intent.model.ModelIntent.selectMany">selectMany</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.update" href="#uql.intent.model.ModelIntent.update">update</a></code></li>
<li><code><a title="uql.intent.model.ModelIntent.updateMany" href="#uql.intent.model.ModelIntent.updateMany">updateMany</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>