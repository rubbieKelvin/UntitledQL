<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uql.model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uql.model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from __future__ import annotations

from django.db.models import Q, Model
from django.db.models.fields import Field

from typing import Any
from typing import Callable
from typing import TypedDict
from typing import Literal
from typing import cast
from typing_extensions import NotRequired

from rest_framework.request import Request
from rest_framework.serializers import ModelSerializer

from .constants import CellFlags
from .constants import ModelOperations
from .constants import types


class ForeignKeyTyping(TypedDict):
    &#34;&#34;&#34;data structure for foreign keys&#34;&#34;&#34;

    model: type[Model]
    type: Literal[&#34;LIST&#34;] | Literal[&#34;OBJECT&#34;]


class SelectPermissionTyping(TypedDict):
    &#34;&#34;&#34;data structure for permission unit&#34;&#34;&#34;

    column: CellFlags | list[str]  # these are the columns, permitted to be read
    row: CellFlags | Q  # queries the rows that could be read


class DeletePermissionTyping(TypedDict):
    row: CellFlags | Q  # queries the row that could be deleted


class InsertPermissionTyping(TypedDict):
    &#34;&#34;&#34;a permission unit for insert operations.
    - check is a function that takes in request and the _set values to check if the values are valid
    &#34;&#34;&#34;

    # the columns that are allowed to be inserted
    column: CellFlags | list[str]

    # the columns that must be inserted
    requiredFields: NotRequired[list[str]]

    # checks the data that&#39;s about to be inserted.
    # if false, insertion will not be permitted
    # - (request: Request, values: dict[str, any]) -&gt; bool
    check: NotRequired[
        Callable[[Request, dict[str, Any]], bool]
    ]  # takes in request and the attrs to set


class PartialUpdateTyping(TypedDict):
    &#34;&#34;&#34;This is the value passed to the update, updateMany intent ans on object to be updated.
    pk is the primary key of the row
    partial is the data that would be updated in the row

    Args:
        TypedDict (_type_): _description_
    &#34;&#34;&#34;

    pk: types.Pk
    partial: dict[str, Any]


class UpdatePermissionTyping(TypedDict):
    &#34;&#34;&#34;a permission unit, for updates operations.
    - row is a query to get the list of updatable queryset
    - check is a function that takes in request and the _set values to check if the values are valid
    &#34;&#34;&#34;

    # the columns that could be updated
    column: CellFlags | list[str]

    # the possible rows that could be updated
    row: CellFlags | Q

    # checks the data that&#39;s about to be updated,
    # if it returns false, update will not be allowed
    # - (request: Request, partial: PartialUpdateTyping) -&gt; bool
    check: NotRequired[Callable[[Request, PartialUpdateTyping], bool]]


class ModelPermissionTyping(TypedDict):
    &#34;&#34;&#34;data stutructure for permission config&#34;&#34;&#34;

    select: NotRequired[SelectPermissionTyping | None]
    insert: NotRequired[InsertPermissionTyping | None]
    update: NotRequired[UpdatePermissionTyping | None]
    delete: NotRequired[DeletePermissionTyping | None]


class ModelConfig:
    modelConfigs: dict[str, ModelConfig] = {}

    def __init__(
        self,
        *,
        model: type[Model],
        foreignKeys: dict[str, ForeignKeyTyping] | None = None,
        permissions: dict[str, Callable[[types.Pk | None], ModelPermissionTyping]]
        | None = None,
        allowedOperations: list[ModelOperations] | None = None,
    ) -&gt; None:
        self.model = model
        self.foreignKeys = foreignKeys or {}
        self.permissions = permissions or {}
        self.allowedOperations = allowedOperations or ModelOperations.all()

        # add model configs
        # helpful to fetch configurations for feriegn keys
        # specified in other configurations
        # ------------------------------------------------
        # ? see self.getConfig
        self.modelConfigs[self.name] = self

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{self.__class__.__name__} model={self.name.title()} fk={self.foreignKeys}, perimissions={self.permissions}&gt;&#34;

    @staticmethod
    def getModelName(model: type[Model]) -&gt; str:
        return model._meta.label_lower

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;returns the name of the model.&#34;&#34;&#34;
        return self.getModelName(self.model)

    @staticmethod
    def getConfig(model: type[Model]) -&gt; ModelConfig | None:
        &#34;&#34;&#34;fetchs a model configuration if the model has been wrapped in the ModelConfig class.
        this should use the same method of model name generation used in ModelConfig.name
        &#34;&#34;&#34;
        return ModelConfig.modelConfigs.get(ModelConfig.getModelName(model))

    def createSerializerClass(
        self, role: str, _parents: list[type[Model]] | None = None
    ) -&gt; type[ModelSerializer]:
        &#34;&#34;&#34;Creates a model serialiser class from user&#39;s role and operation type,
        which determines the kind of serializer that would be produced. depending on what
        data the user with `role` is permitted to access via self.permissions,
        certain data would be hidden. foreign keys will also be referred to in permissions
        if that model is registered in a ModelConfig class, the pemissions given to that model
        would apply to it&#39;s relationship.

        Args:
            role (str): the user&#39;s role
            _parents (list[type[Model]], optional): list of all the models that&#39;s been called
                before this in linear manner, with each model traversing all the way up directly
                to it&#39;s parent. this is an effort to fix the infinte relationship loop, where a foreign model
                also referenced the parent model in it&#39;s serializer.

        Raises:
            TypeError: if the opration is invalid
            PermissionError: if the role is not sufficient for it&#39;s operation

        Returns:
            type[ModelSerializer]: returns the serializer class
        &#34;&#34;&#34;
        parents = _parents or []

        # get the permission from function. we do not need to pass the userid
        # as we only govern fetching columns here. we can simply pass None
        permission = self.permissions.get(role, lambda _: {})(None)
        selectPermission = permission.get(&#34;select&#34;)

        if not (
            permission
            and permission.get(&#34;select&#34;)
            and cast(SelectPermissionTyping, permission.get(&#34;select&#34;, {})).get(&#34;row&#34;)
        ):
            raise PermissionError(
                f&#39;User with role: &#34;{role}&#34; cannot select {self.name}&#39;, 401
            )

        selectPermission = cast(SelectPermissionTyping, selectPermission)

        class Sr(ModelSerializer):
            class Meta:
                model = self.model
                # for the fields, we want to include all the specified
                # foreign keys along side the base fields.
                # setting fields to &#39;__all__&#39; isnt enough to fetch all specified fields from column,
                # hence this custom implementation.
                fields = (
                    [
                        field.name
                        for field in self.model._meta.get_fields()
                        if isinstance(field, Field)
                    ]
                    + [fk for fk in self.foreignKeys.keys()]
                    if selectPermission[&#34;column&#34;] == CellFlags.ALL
                    else selectPermission[&#34;column&#34;]
                )

            def get_fields(*_):  # TODO: test if *_ could replace self
                # get already defined fields from serializer class
                fields = super().get_fields()

                # create serializers for defined foreignkeys
                # and inject them into serializer fields
                for name, fk in self.foreignKeys.items():
                    if fk[&#34;model&#34;] in parents:
                        # skip this model if it&#39;s been referenced somewhere
                        # from this node up from the parent&#39;s model root
                        continue

                    modelConfig: ModelConfig | None = ModelConfig.getConfig(fk[&#34;model&#34;])

                    if modelConfig:
                        _sr = modelConfig.createSerializerClass(
                            role, _parents=[*parents, self.model]
                        )
                        fields[name] = _sr(many=fk[&#34;type&#34;] == &#34;LIST&#34;)
                return fields

        return Sr


def fullPermissionAccess() -&gt; ModelPermissionTyping:
    &#34;&#34;&#34;returns a modelpermission that grants complete access to all model operations

    Returns:
        ModelPermissionTyping
    &#34;&#34;&#34;
    return {
        &#34;delete&#34;: {&#34;row&#34;: CellFlags.ALL},
        &#34;select&#34;: {&#34;column&#34;: CellFlags.ALL, &#34;row&#34;: CellFlags.ALL},
        &#34;insert&#34;: {
            &#34;column&#34;: CellFlags.ALL,
            &#34;requiredFields&#34;: [],
            &#34;check&#34;: lambda request, params: True,
        },
        &#34;update&#34;: {&#34;column&#34;: CellFlags.ALL, &#34;row&#34;: CellFlags.ALL},
    }</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="uql.model.fullPermissionAccess"><code class="name flex">
<span>def <span class="ident">fullPermissionAccess</span></span>(<span>) ‑> <a title="uql.model.ModelPermissionTyping" href="#uql.model.ModelPermissionTyping">ModelPermissionTyping</a></span>
</code></dt>
<dd>
<div class="desc"><p>returns a modelpermission that grants complete access to all model operations</p>
<h2 id="returns">Returns</h2>
<p>ModelPermissionTyping</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fullPermissionAccess() -&gt; ModelPermissionTyping:
    &#34;&#34;&#34;returns a modelpermission that grants complete access to all model operations

    Returns:
        ModelPermissionTyping
    &#34;&#34;&#34;
    return {
        &#34;delete&#34;: {&#34;row&#34;: CellFlags.ALL},
        &#34;select&#34;: {&#34;column&#34;: CellFlags.ALL, &#34;row&#34;: CellFlags.ALL},
        &#34;insert&#34;: {
            &#34;column&#34;: CellFlags.ALL,
            &#34;requiredFields&#34;: [],
            &#34;check&#34;: lambda request, params: True,
        },
        &#34;update&#34;: {&#34;column&#34;: CellFlags.ALL, &#34;row&#34;: CellFlags.ALL},
    }</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="uql.model.DeletePermissionTyping"><code class="flex name class">
<span>class <span class="ident">DeletePermissionTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeletePermissionTyping(TypedDict):
    row: CellFlags | Q  # queries the row that could be deleted</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.DeletePermissionTyping.row"><code class="name">var <span class="ident">row</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | django.db.models.query_utils.Q</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uql.model.ForeignKeyTyping"><code class="flex name class">
<span>class <span class="ident">ForeignKeyTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>data structure for foreign keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ForeignKeyTyping(TypedDict):
    &#34;&#34;&#34;data structure for foreign keys&#34;&#34;&#34;

    model: type[Model]
    type: Literal[&#34;LIST&#34;] | Literal[&#34;OBJECT&#34;]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.ForeignKeyTyping.model"><code class="name">var <span class="ident">model</span> : type[django.db.models.base.Model]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.ForeignKeyTyping.type"><code class="name">var <span class="ident">type</span> : Union[Literal['LIST'], Literal['OBJECT']]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uql.model.InsertPermissionTyping"><code class="flex name class">
<span>class <span class="ident">InsertPermissionTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>a permission unit for insert operations.
- check is a function that takes in request and the _set values to check if the values are valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InsertPermissionTyping(TypedDict):
    &#34;&#34;&#34;a permission unit for insert operations.
    - check is a function that takes in request and the _set values to check if the values are valid
    &#34;&#34;&#34;

    # the columns that are allowed to be inserted
    column: CellFlags | list[str]

    # the columns that must be inserted
    requiredFields: NotRequired[list[str]]

    # checks the data that&#39;s about to be inserted.
    # if false, insertion will not be permitted
    # - (request: Request, values: dict[str, any]) -&gt; bool
    check: NotRequired[
        Callable[[Request, dict[str, Any]], bool]
    ]  # takes in request and the attrs to set</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.InsertPermissionTyping.check"><code class="name">var <span class="ident">check</span> : Callable[[rest_framework.request.Request, dict[str, Any]], bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.InsertPermissionTyping.column"><code class="name">var <span class="ident">column</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.InsertPermissionTyping.requiredFields"><code class="name">var <span class="ident">requiredFields</span> : list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uql.model.ModelConfig"><code class="flex name class">
<span>class <span class="ident">ModelConfig</span></span>
<span>(</span><span>*, model: type[Model], foreignKeys: dict[str, <a title="uql.model.ForeignKeyTyping" href="#uql.model.ForeignKeyTyping">ForeignKeyTyping</a>] | None = None, permissions: dict[str, Callable[[types.Pk | None], <a title="uql.model.ModelPermissionTyping" href="#uql.model.ModelPermissionTyping">ModelPermissionTyping</a>]] | None = None, allowedOperations: list[ModelOperations] | None = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelConfig:
    modelConfigs: dict[str, ModelConfig] = {}

    def __init__(
        self,
        *,
        model: type[Model],
        foreignKeys: dict[str, ForeignKeyTyping] | None = None,
        permissions: dict[str, Callable[[types.Pk | None], ModelPermissionTyping]]
        | None = None,
        allowedOperations: list[ModelOperations] | None = None,
    ) -&gt; None:
        self.model = model
        self.foreignKeys = foreignKeys or {}
        self.permissions = permissions or {}
        self.allowedOperations = allowedOperations or ModelOperations.all()

        # add model configs
        # helpful to fetch configurations for feriegn keys
        # specified in other configurations
        # ------------------------------------------------
        # ? see self.getConfig
        self.modelConfigs[self.name] = self

    def __repr__(self) -&gt; str:
        return f&#34;&lt;{self.__class__.__name__} model={self.name.title()} fk={self.foreignKeys}, perimissions={self.permissions}&gt;&#34;

    @staticmethod
    def getModelName(model: type[Model]) -&gt; str:
        return model._meta.label_lower

    @property
    def name(self) -&gt; str:
        &#34;&#34;&#34;returns the name of the model.&#34;&#34;&#34;
        return self.getModelName(self.model)

    @staticmethod
    def getConfig(model: type[Model]) -&gt; ModelConfig | None:
        &#34;&#34;&#34;fetchs a model configuration if the model has been wrapped in the ModelConfig class.
        this should use the same method of model name generation used in ModelConfig.name
        &#34;&#34;&#34;
        return ModelConfig.modelConfigs.get(ModelConfig.getModelName(model))

    def createSerializerClass(
        self, role: str, _parents: list[type[Model]] | None = None
    ) -&gt; type[ModelSerializer]:
        &#34;&#34;&#34;Creates a model serialiser class from user&#39;s role and operation type,
        which determines the kind of serializer that would be produced. depending on what
        data the user with `role` is permitted to access via self.permissions,
        certain data would be hidden. foreign keys will also be referred to in permissions
        if that model is registered in a ModelConfig class, the pemissions given to that model
        would apply to it&#39;s relationship.

        Args:
            role (str): the user&#39;s role
            _parents (list[type[Model]], optional): list of all the models that&#39;s been called
                before this in linear manner, with each model traversing all the way up directly
                to it&#39;s parent. this is an effort to fix the infinte relationship loop, where a foreign model
                also referenced the parent model in it&#39;s serializer.

        Raises:
            TypeError: if the opration is invalid
            PermissionError: if the role is not sufficient for it&#39;s operation

        Returns:
            type[ModelSerializer]: returns the serializer class
        &#34;&#34;&#34;
        parents = _parents or []

        # get the permission from function. we do not need to pass the userid
        # as we only govern fetching columns here. we can simply pass None
        permission = self.permissions.get(role, lambda _: {})(None)
        selectPermission = permission.get(&#34;select&#34;)

        if not (
            permission
            and permission.get(&#34;select&#34;)
            and cast(SelectPermissionTyping, permission.get(&#34;select&#34;, {})).get(&#34;row&#34;)
        ):
            raise PermissionError(
                f&#39;User with role: &#34;{role}&#34; cannot select {self.name}&#39;, 401
            )

        selectPermission = cast(SelectPermissionTyping, selectPermission)

        class Sr(ModelSerializer):
            class Meta:
                model = self.model
                # for the fields, we want to include all the specified
                # foreign keys along side the base fields.
                # setting fields to &#39;__all__&#39; isnt enough to fetch all specified fields from column,
                # hence this custom implementation.
                fields = (
                    [
                        field.name
                        for field in self.model._meta.get_fields()
                        if isinstance(field, Field)
                    ]
                    + [fk for fk in self.foreignKeys.keys()]
                    if selectPermission[&#34;column&#34;] == CellFlags.ALL
                    else selectPermission[&#34;column&#34;]
                )

            def get_fields(*_):  # TODO: test if *_ could replace self
                # get already defined fields from serializer class
                fields = super().get_fields()

                # create serializers for defined foreignkeys
                # and inject them into serializer fields
                for name, fk in self.foreignKeys.items():
                    if fk[&#34;model&#34;] in parents:
                        # skip this model if it&#39;s been referenced somewhere
                        # from this node up from the parent&#39;s model root
                        continue

                    modelConfig: ModelConfig | None = ModelConfig.getConfig(fk[&#34;model&#34;])

                    if modelConfig:
                        _sr = modelConfig.createSerializerClass(
                            role, _parents=[*parents, self.model]
                        )
                        fields[name] = _sr(many=fk[&#34;type&#34;] == &#34;LIST&#34;)
                return fields

        return Sr</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.ModelConfig.modelConfigs"><code class="name">var <span class="ident">modelConfigs</span> : dict[str, <a title="uql.model.ModelConfig" href="#uql.model.ModelConfig">ModelConfig</a>]</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="uql.model.ModelConfig.getConfig"><code class="name flex">
<span>def <span class="ident">getConfig</span></span>(<span>model: type[Model]) ‑> <a title="uql.model.ModelConfig" href="#uql.model.ModelConfig">ModelConfig</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>fetchs a model configuration if the model has been wrapped in the ModelConfig class.
this should use the same method of model name generation used in ModelConfig.name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getConfig(model: type[Model]) -&gt; ModelConfig | None:
    &#34;&#34;&#34;fetchs a model configuration if the model has been wrapped in the ModelConfig class.
    this should use the same method of model name generation used in ModelConfig.name
    &#34;&#34;&#34;
    return ModelConfig.modelConfigs.get(ModelConfig.getModelName(model))</code></pre>
</details>
</dd>
<dt id="uql.model.ModelConfig.getModelName"><code class="name flex">
<span>def <span class="ident">getModelName</span></span>(<span>model: type[Model]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def getModelName(model: type[Model]) -&gt; str:
    return model._meta.label_lower</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="uql.model.ModelConfig.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>returns the name of the model.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self) -&gt; str:
    &#34;&#34;&#34;returns the name of the model.&#34;&#34;&#34;
    return self.getModelName(self.model)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uql.model.ModelConfig.createSerializerClass"><code class="name flex">
<span>def <span class="ident">createSerializerClass</span></span>(<span>self, role: str) ‑> type[rest_framework.serializers.ModelSerializer]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a model serialiser class from user's role and operation type,
which determines the kind of serializer that would be produced. depending on what
data the user with <code>role</code> is permitted to access via self.permissions,
certain data would be hidden. foreign keys will also be referred to in permissions
if that model is registered in a ModelConfig class, the pemissions given to that model
would apply to it's relationship.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>role</code></strong> :&ensp;<code>str</code></dt>
<dd>the user's role</dd>
<dt><strong><code>_parents</code></strong> :&ensp;<code>list[type[Model]]</code>, optional</dt>
<dd>list of all the models that's been called
before this in linear manner, with each model traversing all the way up directly
to it's parent. this is an effort to fix the infinte relationship loop, where a foreign model
also referenced the parent model in it's serializer.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>TypeError</code></dt>
<dd>if the opration is invalid</dd>
<dt><code>PermissionError</code></dt>
<dd>if the role is not sufficient for it's operation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>type[ModelSerializer]</code></dt>
<dd>returns the serializer class</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def createSerializerClass(
    self, role: str, _parents: list[type[Model]] | None = None
) -&gt; type[ModelSerializer]:
    &#34;&#34;&#34;Creates a model serialiser class from user&#39;s role and operation type,
    which determines the kind of serializer that would be produced. depending on what
    data the user with `role` is permitted to access via self.permissions,
    certain data would be hidden. foreign keys will also be referred to in permissions
    if that model is registered in a ModelConfig class, the pemissions given to that model
    would apply to it&#39;s relationship.

    Args:
        role (str): the user&#39;s role
        _parents (list[type[Model]], optional): list of all the models that&#39;s been called
            before this in linear manner, with each model traversing all the way up directly
            to it&#39;s parent. this is an effort to fix the infinte relationship loop, where a foreign model
            also referenced the parent model in it&#39;s serializer.

    Raises:
        TypeError: if the opration is invalid
        PermissionError: if the role is not sufficient for it&#39;s operation

    Returns:
        type[ModelSerializer]: returns the serializer class
    &#34;&#34;&#34;
    parents = _parents or []

    # get the permission from function. we do not need to pass the userid
    # as we only govern fetching columns here. we can simply pass None
    permission = self.permissions.get(role, lambda _: {})(None)
    selectPermission = permission.get(&#34;select&#34;)

    if not (
        permission
        and permission.get(&#34;select&#34;)
        and cast(SelectPermissionTyping, permission.get(&#34;select&#34;, {})).get(&#34;row&#34;)
    ):
        raise PermissionError(
            f&#39;User with role: &#34;{role}&#34; cannot select {self.name}&#39;, 401
        )

    selectPermission = cast(SelectPermissionTyping, selectPermission)

    class Sr(ModelSerializer):
        class Meta:
            model = self.model
            # for the fields, we want to include all the specified
            # foreign keys along side the base fields.
            # setting fields to &#39;__all__&#39; isnt enough to fetch all specified fields from column,
            # hence this custom implementation.
            fields = (
                [
                    field.name
                    for field in self.model._meta.get_fields()
                    if isinstance(field, Field)
                ]
                + [fk for fk in self.foreignKeys.keys()]
                if selectPermission[&#34;column&#34;] == CellFlags.ALL
                else selectPermission[&#34;column&#34;]
            )

        def get_fields(*_):  # TODO: test if *_ could replace self
            # get already defined fields from serializer class
            fields = super().get_fields()

            # create serializers for defined foreignkeys
            # and inject them into serializer fields
            for name, fk in self.foreignKeys.items():
                if fk[&#34;model&#34;] in parents:
                    # skip this model if it&#39;s been referenced somewhere
                    # from this node up from the parent&#39;s model root
                    continue

                modelConfig: ModelConfig | None = ModelConfig.getConfig(fk[&#34;model&#34;])

                if modelConfig:
                    _sr = modelConfig.createSerializerClass(
                        role, _parents=[*parents, self.model]
                    )
                    fields[name] = _sr(many=fk[&#34;type&#34;] == &#34;LIST&#34;)
            return fields

    return Sr</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="uql.model.ModelPermissionTyping"><code class="flex name class">
<span>class <span class="ident">ModelPermissionTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>data stutructure for permission config</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ModelPermissionTyping(TypedDict):
    &#34;&#34;&#34;data stutructure for permission config&#34;&#34;&#34;

    select: NotRequired[SelectPermissionTyping | None]
    insert: NotRequired[InsertPermissionTyping | None]
    update: NotRequired[UpdatePermissionTyping | None]
    delete: NotRequired[DeletePermissionTyping | None]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.ModelPermissionTyping.delete"><code class="name">var <span class="ident">delete</span> : <a title="uql.model.DeletePermissionTyping" href="#uql.model.DeletePermissionTyping">DeletePermissionTyping</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.ModelPermissionTyping.insert"><code class="name">var <span class="ident">insert</span> : <a title="uql.model.InsertPermissionTyping" href="#uql.model.InsertPermissionTyping">InsertPermissionTyping</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.ModelPermissionTyping.select"><code class="name">var <span class="ident">select</span> : <a title="uql.model.SelectPermissionTyping" href="#uql.model.SelectPermissionTyping">SelectPermissionTyping</a> | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="uql.model.ModelPermissionTyping.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>...) ‑> <a title="uql.model.UpdatePermissionTyping" href="#uql.model.UpdatePermissionTyping">UpdatePermissionTyping</a> | None</span>
</code></dt>
<dd>
<div class="desc"><p>D.update([E, ]**F) -&gt; None.
Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:
for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:
for k, v in E: D[k] = v
In either case, this is followed by: for k in F:
D[k] = F[k]</p></div>
</dd>
</dl>
</dd>
<dt id="uql.model.PartialUpdateTyping"><code class="flex name class">
<span>class <span class="ident">PartialUpdateTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This is the value passed to the update, updateMany intent ans on object to be updated.
pk is the primary key of the row
partial is the data that would be updated in the row</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>TypedDict</code></strong> :&ensp;<code>_type_</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PartialUpdateTyping(TypedDict):
    &#34;&#34;&#34;This is the value passed to the update, updateMany intent ans on object to be updated.
    pk is the primary key of the row
    partial is the data that would be updated in the row

    Args:
        TypedDict (_type_): _description_
    &#34;&#34;&#34;

    pk: types.Pk
    partial: dict[str, Any]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.PartialUpdateTyping.partial"><code class="name">var <span class="ident">partial</span> : dict[str, typing.Any]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.PartialUpdateTyping.pk"><code class="name">var <span class="ident">pk</span> : int | str</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uql.model.SelectPermissionTyping"><code class="flex name class">
<span>class <span class="ident">SelectPermissionTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>data structure for permission unit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SelectPermissionTyping(TypedDict):
    &#34;&#34;&#34;data structure for permission unit&#34;&#34;&#34;

    column: CellFlags | list[str]  # these are the columns, permitted to be read
    row: CellFlags | Q  # queries the rows that could be read</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.SelectPermissionTyping.column"><code class="name">var <span class="ident">column</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.SelectPermissionTyping.row"><code class="name">var <span class="ident">row</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | django.db.models.query_utils.Q</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="uql.model.UpdatePermissionTyping"><code class="flex name class">
<span>class <span class="ident">UpdatePermissionTyping</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>a permission unit, for updates operations.
- row is a query to get the list of updatable queryset
- check is a function that takes in request and the _set values to check if the values are valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UpdatePermissionTyping(TypedDict):
    &#34;&#34;&#34;a permission unit, for updates operations.
    - row is a query to get the list of updatable queryset
    - check is a function that takes in request and the _set values to check if the values are valid
    &#34;&#34;&#34;

    # the columns that could be updated
    column: CellFlags | list[str]

    # the possible rows that could be updated
    row: CellFlags | Q

    # checks the data that&#39;s about to be updated,
    # if it returns false, update will not be allowed
    # - (request: Request, partial: PartialUpdateTyping) -&gt; bool
    check: NotRequired[Callable[[Request, PartialUpdateTyping], bool]]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="uql.model.UpdatePermissionTyping.check"><code class="name">var <span class="ident">check</span> : Callable[[rest_framework.request.Request, <a title="uql.model.PartialUpdateTyping" href="#uql.model.PartialUpdateTyping">PartialUpdateTyping</a>], bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.UpdatePermissionTyping.column"><code class="name">var <span class="ident">column</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | list[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="uql.model.UpdatePermissionTyping.row"><code class="name">var <span class="ident">row</span> : <a title="uql.constants.CellFlags" href="constants/index.html#uql.constants.CellFlags">CellFlags</a> | django.db.models.query_utils.Q</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uql" href="index.html">uql</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="uql.model.fullPermissionAccess" href="#uql.model.fullPermissionAccess">fullPermissionAccess</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="uql.model.DeletePermissionTyping" href="#uql.model.DeletePermissionTyping">DeletePermissionTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.DeletePermissionTyping.row" href="#uql.model.DeletePermissionTyping.row">row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.ForeignKeyTyping" href="#uql.model.ForeignKeyTyping">ForeignKeyTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.ForeignKeyTyping.model" href="#uql.model.ForeignKeyTyping.model">model</a></code></li>
<li><code><a title="uql.model.ForeignKeyTyping.type" href="#uql.model.ForeignKeyTyping.type">type</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.InsertPermissionTyping" href="#uql.model.InsertPermissionTyping">InsertPermissionTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.InsertPermissionTyping.check" href="#uql.model.InsertPermissionTyping.check">check</a></code></li>
<li><code><a title="uql.model.InsertPermissionTyping.column" href="#uql.model.InsertPermissionTyping.column">column</a></code></li>
<li><code><a title="uql.model.InsertPermissionTyping.requiredFields" href="#uql.model.InsertPermissionTyping.requiredFields">requiredFields</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.ModelConfig" href="#uql.model.ModelConfig">ModelConfig</a></code></h4>
<ul class="">
<li><code><a title="uql.model.ModelConfig.createSerializerClass" href="#uql.model.ModelConfig.createSerializerClass">createSerializerClass</a></code></li>
<li><code><a title="uql.model.ModelConfig.getConfig" href="#uql.model.ModelConfig.getConfig">getConfig</a></code></li>
<li><code><a title="uql.model.ModelConfig.getModelName" href="#uql.model.ModelConfig.getModelName">getModelName</a></code></li>
<li><code><a title="uql.model.ModelConfig.modelConfigs" href="#uql.model.ModelConfig.modelConfigs">modelConfigs</a></code></li>
<li><code><a title="uql.model.ModelConfig.name" href="#uql.model.ModelConfig.name">name</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.ModelPermissionTyping" href="#uql.model.ModelPermissionTyping">ModelPermissionTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.ModelPermissionTyping.delete" href="#uql.model.ModelPermissionTyping.delete">delete</a></code></li>
<li><code><a title="uql.model.ModelPermissionTyping.insert" href="#uql.model.ModelPermissionTyping.insert">insert</a></code></li>
<li><code><a title="uql.model.ModelPermissionTyping.select" href="#uql.model.ModelPermissionTyping.select">select</a></code></li>
<li><code><a title="uql.model.ModelPermissionTyping.update" href="#uql.model.ModelPermissionTyping.update">update</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.PartialUpdateTyping" href="#uql.model.PartialUpdateTyping">PartialUpdateTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.PartialUpdateTyping.partial" href="#uql.model.PartialUpdateTyping.partial">partial</a></code></li>
<li><code><a title="uql.model.PartialUpdateTyping.pk" href="#uql.model.PartialUpdateTyping.pk">pk</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.SelectPermissionTyping" href="#uql.model.SelectPermissionTyping">SelectPermissionTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.SelectPermissionTyping.column" href="#uql.model.SelectPermissionTyping.column">column</a></code></li>
<li><code><a title="uql.model.SelectPermissionTyping.row" href="#uql.model.SelectPermissionTyping.row">row</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="uql.model.UpdatePermissionTyping" href="#uql.model.UpdatePermissionTyping">UpdatePermissionTyping</a></code></h4>
<ul class="">
<li><code><a title="uql.model.UpdatePermissionTyping.check" href="#uql.model.UpdatePermissionTyping.check">check</a></code></li>
<li><code><a title="uql.model.UpdatePermissionTyping.column" href="#uql.model.UpdatePermissionTyping.column">column</a></code></li>
<li><code><a title="uql.model.UpdatePermissionTyping.row" href="#uql.model.UpdatePermissionTyping.row">row</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>