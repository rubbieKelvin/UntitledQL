<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>uql.views API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>uql.views</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .config import UQLConfig
from .intent.model import ModelIntent
from .intent import IntentFunction
from .utils import templates as t
from .utils.select import selectKeys
from .utils.types import isArray
from .utils.types import isMap
from .exceptions import RequestHandlingError
from .constants import errors as errorConstants
from .constants.types import UQLRequestBodyTyping
from .constants.types import UQLResponseBodyTyping
from django.http.request import QueryDict

from rest_framework.views import APIView
from rest_framework.request import Request
from rest_framework.response import Response
from rest_framework.parsers import JSONParser
from rest_framework.parsers import MultiPartParser

import json
import typing


def UQLView(config: type[UQLConfig]) -&gt; type[APIView]:
    &#34;&#34;&#34;Creates an APIView class that is built on config.

    Args:
        config (type[UQLConfig]): _description_

    Returns:
        type[APIView]: _description_
    &#34;&#34;&#34;

    def rootErrorHandler(fn):
        &#34;&#34;&#34;
        Decorates the response to handle all errors from view.
        &#34;&#34;&#34;

        def _(*args, **kwargs) -&gt; Response:

            try:
                res: UQLResponseBodyTyping = fn(*args, **kwargs)

            except BaseException as e:
                if config.raiseExceptions:
                    # raise error as per stated in app&#39;s configuration
                    raise e

                if type(e) == RequestHandlingError:
                    e = typing.cast(RequestHandlingError, e)
                    return Response(
                        t.error(
                            e.message,
                            errorCode=e.errorCode,
                            statusCode=e.statusCode,
                            summary=e.summary,
                        ),
                        status=e.statusCode,
                    )
                else:
                    return Response(
                        t.error(
                            e.args[0] if len(e.args) &gt; 0 else e.__class__.__name__,
                            errorCode=e.__class__.__name__,
                            statusCode=e.args[1] if len(e.args) &gt; 1 else 500,
                            summary=None,
                        )
                    )

            if type(res) == list:
                return Response(res, status=200)

            # TODO: review res
            return Response(res, status=res[&#34;statusCode&#34;])

        return _

    # this is the root for intents
    modelRoots = {}
    functionRoots = {}

    # load up func roots
    for wrapper in config.functions:
        functionRoots[f&#34;functions.{wrapper.name}&#34;] = wrapper

    # load up model roots
    for modelConfig in config.models:
        modelRoots.update(ModelIntent(config, modelConfig).intenthandlers)

    class Adapter(APIView):
        ROOT: dict[str, IntentFunction] = {**modelRoots, **functionRoots}
        parser_classes = [JSONParser, MultiPartParser]

        def handleIntent(
            self,
            request: Request,
            intent: str | None,
            fields: bool | dict | None,
            arguments: dict[str, typing.Any],
        ) -&gt; UQLResponseBodyTyping:
            # intents are required to use this app
            if intent == None:
                raise RequestHandlingError(
                    &#34;No specified intent&#34;,
                    errorCode=errorConstants.NO_INTENT,
                    statusCode=400,
                    summary=&#34;Could not find any specified intent during request call&#34;,
                )

            if not (intent in self.ROOT):
                raise RequestHandlingError(
                    &#34;Intent does not exist&#34;,
                    errorCode=errorConstants.INEXISTENT_INTENT,
                    statusCode=400,
                    summary=f&#39;Intent &#34;{intent}&#34; does not exist in uql root.\nThis is a development error, refer to schema to see available intents.&#39;,
                )

            # get the function that would handles current request from root
            handler: IntentFunction = self.ROOT[intent]

            warning = (
                &#34;fields not specified (or set to null), you might get an empty data&#34;
                if fields == None
                else None
            )

            data = handler(request, arguments)

            # raise an error if the intent handler returned any thing other than
            # the instances of dict or list or tuple or none
            if not (data == None or isMap(data) or isArray(data)):
                raise RequestHandlingError(
                    &#34;Invalid handler output&#34;,
                    errorCode=errorConstants.INVALID_REQUEST_HANDLER_OUTPUT,
                    statusCode=500,
                    summary=f&#34;Intent ({intent}) handler returned a {type(data)} type. allowed output types are dict, list, none&#34;,
                )

            # if there&#39;s no data, do not filter response
            if data == None:
                return {
                    &#34;data&#34;: None,
                    &#34;error&#34;: None,
                    &#34;warning&#34;: warning,
                    &#34;statusCode&#34;: 200,
                }

            # psuedo data function
            _data = lambda: data

            if isMap(data):
                _data = lambda: selectKeys(
                    typing.cast(dict, data), typing.cast(dict, fields)
                )
            else:
                _data = lambda: [
                    selectKeys(i, typing.cast(dict, fields)) if isMap(i) else i
                    for i in typing.cast(typing.Sequence[typing.Any], data)
                ]

            # check fields to compute result
            if fields:
                if type(fields) == dict:
                    result = _data()
                else:
                    result = data
            else:
                result = None

            # return result
            return {
                &#34;data&#34;: result,
                &#34;warning&#34;: warning,
                &#34;statusCode&#34;: 200,
                &#34;error&#34;: None,
            }

        def get(self, request: Request) -&gt; Response:
            root = self.ROOT
            schema = {key: {**val.json(), &#34;name&#34;: key} for key, val in root.items()}
            return Response({&#34;schema&#34;: schema or None})

        @rootErrorHandler
        def post(
            self, request: Request
        ) -&gt; UQLResponseBodyTyping | list[UQLResponseBodyTyping]:
            # get response data
            body = request.data

            if type(body) == QueryDict:
                formdata_body = typing.cast(QueryDict, request.data)
                # look for &#39;$uql.request.body&#39; in formdata
                body = typing.cast(
                    dict | list,
                    json.loads(formdata_body.get(&#34;$uql.request.body&#34;, &#34;{}&#34;)),
                )

            if type(body) == dict:
                body = typing.cast(UQLRequestBodyTyping, body)
                body.setdefault(&#34;intent&#34;, None)
                body.setdefault(&#34;fields&#34;, None)
                body.setdefault(&#34;args&#34;, {})

                # tells the app what function to call
                intent = body[&#34;intent&#34;]

                # specifies the return type of the function;
                # should only be used on dicts or lists of dicts
                # -- bool   : include all fields or not
                # -- dict   : include selected fields
                # -- None   : no fields
                fields = body[&#34;fields&#34;]

                # arguments are values to be passed into the handler function
                # there are required and optional arguments, so the keys in this data should meet the requirements
                arguments = body[&#34;args&#34;]

                return self.handleIntent(request, intent, fields, arguments)

            elif type(body) == list:

                # sequentially run multiple intent in on call
                body = typing.cast(list[UQLRequestBodyTyping], body)
                responseData: list[UQLResponseBodyTyping] = []

                for cell in body:
                    cell.setdefault(&#34;intent&#34;, None)
                    cell.setdefault(&#34;fields&#34;, None)
                    cell.setdefault(&#34;args&#34;, {})

                    responseData.append(
                        self.handleIntent(
                            request, cell[&#34;intent&#34;], cell[&#34;fields&#34;], cell[&#34;args&#34;]
                        )
                    )
                return responseData
            else:
                raise RequestHandlingError(
                    f&#34;Unknown body type: {type(body)}&#34;,
                    statusCode=400,
                    errorCode=errorConstants.INVALID_REQUEST_BODY,
                )

    return Adapter</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="uql.views.UQLView"><code class="name flex">
<span>def <span class="ident">UQLView</span></span>(<span>config: type[<a title="uql.config.UQLConfig" href="config.html#uql.config.UQLConfig">UQLConfig</a>]) ‑> type[rest_framework.views.APIView]</span>
</code></dt>
<dd>
<div class="desc"><p>Creates an APIView class that is built on config.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>type[UQLConfig]</code></dt>
<dd><em>description</em></dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>type[APIView]</code></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UQLView(config: type[UQLConfig]) -&gt; type[APIView]:
    &#34;&#34;&#34;Creates an APIView class that is built on config.

    Args:
        config (type[UQLConfig]): _description_

    Returns:
        type[APIView]: _description_
    &#34;&#34;&#34;

    def rootErrorHandler(fn):
        &#34;&#34;&#34;
        Decorates the response to handle all errors from view.
        &#34;&#34;&#34;

        def _(*args, **kwargs) -&gt; Response:

            try:
                res: UQLResponseBodyTyping = fn(*args, **kwargs)

            except BaseException as e:
                if config.raiseExceptions:
                    # raise error as per stated in app&#39;s configuration
                    raise e

                if type(e) == RequestHandlingError:
                    e = typing.cast(RequestHandlingError, e)
                    return Response(
                        t.error(
                            e.message,
                            errorCode=e.errorCode,
                            statusCode=e.statusCode,
                            summary=e.summary,
                        ),
                        status=e.statusCode,
                    )
                else:
                    return Response(
                        t.error(
                            e.args[0] if len(e.args) &gt; 0 else e.__class__.__name__,
                            errorCode=e.__class__.__name__,
                            statusCode=e.args[1] if len(e.args) &gt; 1 else 500,
                            summary=None,
                        )
                    )

            if type(res) == list:
                return Response(res, status=200)

            # TODO: review res
            return Response(res, status=res[&#34;statusCode&#34;])

        return _

    # this is the root for intents
    modelRoots = {}
    functionRoots = {}

    # load up func roots
    for wrapper in config.functions:
        functionRoots[f&#34;functions.{wrapper.name}&#34;] = wrapper

    # load up model roots
    for modelConfig in config.models:
        modelRoots.update(ModelIntent(config, modelConfig).intenthandlers)

    class Adapter(APIView):
        ROOT: dict[str, IntentFunction] = {**modelRoots, **functionRoots}
        parser_classes = [JSONParser, MultiPartParser]

        def handleIntent(
            self,
            request: Request,
            intent: str | None,
            fields: bool | dict | None,
            arguments: dict[str, typing.Any],
        ) -&gt; UQLResponseBodyTyping:
            # intents are required to use this app
            if intent == None:
                raise RequestHandlingError(
                    &#34;No specified intent&#34;,
                    errorCode=errorConstants.NO_INTENT,
                    statusCode=400,
                    summary=&#34;Could not find any specified intent during request call&#34;,
                )

            if not (intent in self.ROOT):
                raise RequestHandlingError(
                    &#34;Intent does not exist&#34;,
                    errorCode=errorConstants.INEXISTENT_INTENT,
                    statusCode=400,
                    summary=f&#39;Intent &#34;{intent}&#34; does not exist in uql root.\nThis is a development error, refer to schema to see available intents.&#39;,
                )

            # get the function that would handles current request from root
            handler: IntentFunction = self.ROOT[intent]

            warning = (
                &#34;fields not specified (or set to null), you might get an empty data&#34;
                if fields == None
                else None
            )

            data = handler(request, arguments)

            # raise an error if the intent handler returned any thing other than
            # the instances of dict or list or tuple or none
            if not (data == None or isMap(data) or isArray(data)):
                raise RequestHandlingError(
                    &#34;Invalid handler output&#34;,
                    errorCode=errorConstants.INVALID_REQUEST_HANDLER_OUTPUT,
                    statusCode=500,
                    summary=f&#34;Intent ({intent}) handler returned a {type(data)} type. allowed output types are dict, list, none&#34;,
                )

            # if there&#39;s no data, do not filter response
            if data == None:
                return {
                    &#34;data&#34;: None,
                    &#34;error&#34;: None,
                    &#34;warning&#34;: warning,
                    &#34;statusCode&#34;: 200,
                }

            # psuedo data function
            _data = lambda: data

            if isMap(data):
                _data = lambda: selectKeys(
                    typing.cast(dict, data), typing.cast(dict, fields)
                )
            else:
                _data = lambda: [
                    selectKeys(i, typing.cast(dict, fields)) if isMap(i) else i
                    for i in typing.cast(typing.Sequence[typing.Any], data)
                ]

            # check fields to compute result
            if fields:
                if type(fields) == dict:
                    result = _data()
                else:
                    result = data
            else:
                result = None

            # return result
            return {
                &#34;data&#34;: result,
                &#34;warning&#34;: warning,
                &#34;statusCode&#34;: 200,
                &#34;error&#34;: None,
            }

        def get(self, request: Request) -&gt; Response:
            root = self.ROOT
            schema = {key: {**val.json(), &#34;name&#34;: key} for key, val in root.items()}
            return Response({&#34;schema&#34;: schema or None})

        @rootErrorHandler
        def post(
            self, request: Request
        ) -&gt; UQLResponseBodyTyping | list[UQLResponseBodyTyping]:
            # get response data
            body = request.data

            if type(body) == QueryDict:
                formdata_body = typing.cast(QueryDict, request.data)
                # look for &#39;$uql.request.body&#39; in formdata
                body = typing.cast(
                    dict | list,
                    json.loads(formdata_body.get(&#34;$uql.request.body&#34;, &#34;{}&#34;)),
                )

            if type(body) == dict:
                body = typing.cast(UQLRequestBodyTyping, body)
                body.setdefault(&#34;intent&#34;, None)
                body.setdefault(&#34;fields&#34;, None)
                body.setdefault(&#34;args&#34;, {})

                # tells the app what function to call
                intent = body[&#34;intent&#34;]

                # specifies the return type of the function;
                # should only be used on dicts or lists of dicts
                # -- bool   : include all fields or not
                # -- dict   : include selected fields
                # -- None   : no fields
                fields = body[&#34;fields&#34;]

                # arguments are values to be passed into the handler function
                # there are required and optional arguments, so the keys in this data should meet the requirements
                arguments = body[&#34;args&#34;]

                return self.handleIntent(request, intent, fields, arguments)

            elif type(body) == list:

                # sequentially run multiple intent in on call
                body = typing.cast(list[UQLRequestBodyTyping], body)
                responseData: list[UQLResponseBodyTyping] = []

                for cell in body:
                    cell.setdefault(&#34;intent&#34;, None)
                    cell.setdefault(&#34;fields&#34;, None)
                    cell.setdefault(&#34;args&#34;, {})

                    responseData.append(
                        self.handleIntent(
                            request, cell[&#34;intent&#34;], cell[&#34;fields&#34;], cell[&#34;args&#34;]
                        )
                    )
                return responseData
            else:
                raise RequestHandlingError(
                    f&#34;Unknown body type: {type(body)}&#34;,
                    statusCode=400,
                    errorCode=errorConstants.INVALID_REQUEST_BODY,
                )

    return Adapter</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="uql" href="index.html">uql</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="uql.views.UQLView" href="#uql.views.UQLView">UQLView</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>